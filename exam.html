<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Examen DCU</title>
    <script src="js/phaser.min.js"></script>
    <link rel="stylesheet" href="css/screen.css" />
  </head>

  <body>
    <script type="text/javascript">
      var config = {
        type: Phaser.AUTO,
        width: 800,
        height: 400,
        transparent: true,
        physics: {
          default: "arcade",
          arcade: {
            fps: 120,
            gravity: { y: 300 },
          },
        },
        scene: {
          preload: preload,
          create: create,
          update: update,
        },
      };

      var player,
        coins,
        platforms,
        cursors,
        score = 0,
        scoreText,
        acceleration = 600,
        wasStanding = false,
        edgeTimer = 0,
        jumping = false,
        prevPos = 0,
        yPos = 0,
        touchJump = false,
        touchJumpThreshold = 5,
        touchSlider,
        sliderBar,
        sliderKnob,
        touchMoving = false,
        touchMoveThreshold = 3,
        largeThumbMoveAcross = 25,
        thumbSizeOffset = 60,
        startX,
        onLadder = false,
        ladders,
        shell,
        shellSpeed = 500,
        heartOutlines = [],
        hearts = [],
        maxHearts = 3,
        invicibility,
        emitter,
        superPlayerSpeed = 400,
        vulnerableTime = 1000,
        maxPlayerSpeed = 200,
        heroColor = new Phaser.Display.Color(255, 255, 255),
        invincibleColor = new Phaser.Display.Color(56, 194, 239),
        coinTweens = [],
        baddies,
        camera,
        hud,
        mushroom,
        jumpVelocity = -165,
        jumpVelocitySmall = -165,
        jumpVelocityBig = -330,
        questionMarkBlock;

      var game = new Phaser.Game(config);

      function preload() {
        this.load.setBaseURL("assets/");
        this.load.image("ground", "platform.jpg");
        this.load.image("coin", "coin.jpg");
        this.load.image("hero", "hero.jpg");
        this.load.image("logo", "digitherium-logo.jpg");
        this.load.image("touch-slider", "touch-slider.png");
        this.load.image("touch-knob", "touch-knob.png");
        this.load.image("baddie", "baddie.jpg");
        this.load.image("ladder", "ladder.png");
        this.load.image("shell", "shell.png");
        this.load.image("heart", "heart.png");
        this.load.image("heart-filled", "heart-filled.png");
        this.load.image("spikes", "spikes.png");
        this.load.image("powerup", "powerup-16.jpg");
        this.load.image("dust", "dust-small.jpg");
        this.load.image("hero-small", "hero-16.jpg");
        this.load.image("question-mark-block", "question-mark-block.jpg");
        this.load.image("empty-box", "empty-box.jpg");
      }

      function create() {
        this.physics.world.setBounds(0, 0, 1630, 400);

        var logo = this.add.sprite(config.width / 2, config.height / 2, "logo");
        logo.alpha = 0.4;
        logo.setScale(0.5);
        logo.setScrollFactor(0.2);

        this.input.addPointer(1);
        platforms = this.physics.add.staticGroup();

        platforms.create(1300, 400, "ground").setScale(2).refreshBody();
        platforms.create(400, 400, "ground").setScale(2).refreshBody();
        platforms.create(150, 240, "ground");
        platforms.create(860, 190, "ground");

        player = this.physics.add.sprite(40, 350, "hero-small");
        player.setCollideWorldBounds(true);
        player.setBounce(0);
        player.body.maxVelocity.x = 200;
        player.body.maxVelocity.y = 500;
        player.invulnerable = false;
        player.hearts = maxHearts;
        player.invincible = false;

        cursors = this.input.keyboard.createCursorKeys();

        shell = this.physics.add.sprite(1500, 350, "shell");

        coins = this.physics.add.group({
          key: "coin",
          repeat: 11,
          setXY: { x: 12, y: 0, stepX: 70 },
        });

        coins.children.iterate(function (child) {
          child.setBounceY(Phaser.Math.FloatBetween(0.4, 0.8));
        });

        scoreText = this.add.text(46, 16, "0", {
          fontSize: "32px",
          fill: "#fff",
        });

        baddies = this.physics.add.group();
        baddie = baddies.create(1220, 350, "baddie");
        baddie.setOrigin(0.5, 0.5);
        baddie.setCollideWorldBounds(true);
        baddie.body.velocity.x = -100;
        baddie.maxDistance = 300;
        baddie.previousX = baddie.x;
        baddie = baddies.create(940, 100, "baddie");
        baddie.setOrigin(0.5, 0.5);
        baddie.setCollideWorldBounds(true);
        baddie.body.velocity.x = -100;
        baddie.maxDistance = 250;
        baddie.previousX = baddie.x;

        ladders = this.physics.add.staticGroup();
        ladders.enableBody = true;
        ladder = ladders.create(365, 296, "ladder");
        ladder.body.immovable = true;
        this.physics.add.overlap(player, ladders, isOnLadder, null, this);

        scoreCoin = this.add.sprite(30, 32, "coin");
        scoreCoin.setOrigin(0.5, 0.5);
        scoreCoin.scaleX = 0.5;
        scoreCoin.scaleY = 0.5;

        spikes = this.physics.add.staticGroup();
        spikes.enableBody = true;
        spikes = spikes.create(850, 385, "spikes");
        spikes.body.immovable = true;

        var heartOutline1 = this.add.sprite(760, 38, "heart"),
          heartOutline2 = this.add.sprite(720, 38, "heart"),
          heartOutline3 = this.add.sprite(680, 38, "heart");
        heartOutlines = [heartOutline1, heartOutline2, heartOutline3];
        heart1 = this.add.sprite(760, 38, "heart-filled");
        heart2 = this.add.sprite(720, 38, "heart-filled");
        heart3 = this.add.sprite(680, 38, "heart-filled");
        hearts = [heart1, heart2, heart3];

        invicibility = this.physics.add.sprite(240, 60, "powerup");
        invicibility.setOrigin(0.5, 0.5);

        var particles = this.add.particles("dust");
        emitter = particles.createEmitter();
        emitter.setPosition(player.x, player.y);
        emitter.setSpeed(150);
        emitter.setBlendMode(Phaser.BlendModes.ADD);
        emitter.pause();

        camera = this.cameras.main;
        camera.setBounds(0, 0, 1630, 400);
        camera.startFollow(player, true, 0.05, 0, -200, 120);

        hud = this.add.container(0, 0, [
          scoreCoin,
          scoreText,
          heart1,
          heart2,
          heart3,
          heartOutline1,
          heartOutline2,
          heartOutline3,
        ]);
        hud.setScrollFactor(0);

        mushroom = this.physics.add.sprite(520, 310, "powerup");
        mushroom.setOrigin(0.5, 0.5);
        mushroom.setTintFill(0xff9800);
        mushroom.enableBody = false;
        mushroom.visible = false;
        mushroom.body.setAllowGravity(false);

        questionMarkBlock = this.physics.add.sprite(
          520,
          310,
          "question-mark-block"
        );
        questionMarkBlock.body.setAllowGravity(false);
        questionMarkBlock.setImmovable(true);
        questionMarkBlock.powerup = mushroom;

        this.physics.add.collider(player, platforms);
        this.physics.add.collider(coins, platforms);
        this.physics.add.collider(baddies, platforms);
        this.physics.add.collider(player, ladders, null, checkLadderTop, this);
        this.physics.add.collider(shell, platforms);
        this.physics.add.collider(player, shell, shellHit, null, this);
        this.physics.add.collider(player, spikes, playerHit, null, this);
        this.physics.add.collider(shell, platforms, shellWallHit, null, this);
        this.physics.add.collider(shell, spikes, destroyShell, null, this);
        this.physics.add.collider(invicibility, platforms);
        this.physics.add.collider(mushroom, platforms);
        this.physics.add.collider(
          player,
          questionMarkBlock,
          hitQuestionMarkBlock,
          null,
          this
        );
        this.physics.add.overlap(player, mushroom, collectMushroom, null, this);
        this.physics.add.overlap(
          player,
          invicibility,
          goInvincibile,
          null,
          this
        );
        this.physics.add.overlap(shell, baddies, shellHitBaddie, null, this);
        this.physics.add.overlap(player, coins, collectCoin, null, this);
        this.physics.add.overlap(player, baddies, hitBaddie, null, this);
        buildTouchSlider(this);
      }

      function emptyQuestionBlock(block) {
        block.setTexture("empty-box");

        block.powerup.enableBody = true;

        block.powerup.body.setAllowGravity(true);

        if (Math.floor(Math.random() * 1)) block.powerup.setVelocityX(-80);
        else block.powerup.setVelocityX(80);
      }

      function hitQuestionMarkBlock(player, block) {
        if (block.body.touching.down && !block.hit) {
          block.hit = true;

          block.powerup.visible = true;

          var tween = this.tweens.add({
            targets: block.powerup,
            y: "-=24",
            ease: "Linear",
            duration: 300,
            onComplete: function () {
              emptyQuestionBlock(block);
            },
          });

          var tween = this.tweens.add({
            targets: block,
            y: "-=5",
            ease: "Linear",
            yoyo: true,
            duration: 100,
          });
        }
      }

      function shrinkHero() {
        player.setTexture("hero-small");

        player.setSize(22, 22);

        player.isBig = false;

        player.isChangingSize = false;
      }

      function growHero() {
        player.setTexture("hero");

        player.setSize(32, 32);

        player.isBig = true;

        player.isChangingSize = false;
      }

      function collectMushroom(player, mushroom) {
        player.body.velocity.x = 0;
        player.body.velocity.y = 0;

        player.isChangingSize = true;

        mushroom.disableBody(false, false);

        var tween = this.tweens.add({
          targets: player,
          scaleX: 1.5,
          scaleY: 1.5,
          yoyo: 1,
          repeat: 1,
          ease: "Linear",
          duration: 100,
          onComplete: function () {
            growHero();
          },
        });

        var tween = this.tweens.add({
          targets: mushroom,
          alpha: 0.3,
          angle: 90,
          scaleX: 0.3,
          scaleY: 0.3,
          ease: "Linear",
          duration: 500,
          onComplete: function () {
            destroyGameObject(mushroom);
          },
        });
      }

      function shellWallHit(shell, wall) {
        if (shell.body.onWall()) {
          destroyShell.call(this);
        }
      }
      function goInvincibile(player, invicibility) {
        invicibility.disableBody(false, false);

        player.body.maxVelocity.x = superPlayerSpeed;

        emitter.resume();
        this.tweens.addCounter({
          from: 0,
          to: 100,
          duration: 500,
          yoyo: true,
          repeat: 5,
          onUpdate: function (tween) {
            emitter.setPosition(player.x, player.y);
            var value = Math.floor(tween.getValue()),
              newColorObject = Phaser.Display.Color.Interpolate.ColorWithColor(
                heroColor,
                invincibleColor,
                100,
                value
              ),
              color = Phaser.Display.Color.GetColor(
                newColorObject.r,
                newColorObject.g,
                newColorObject.b
              );
            player.setTint(color);
          },
          onComplete: function () {
            resetInvincibility();
          },
        });
        var tween = this.tweens.add({
          targets: invicibility,
          alpha: 0.3,
          angle: 90,
          scaleX: 3,
          scaleY: 3,
          ease: "Linear",
          duration: 500,
          onComplete: function () {
            destroyGameObject(invicibility);
          },
        });

        player.invincible = true;
      }

      function resetInvincibility() {
        player.invincible = false;

        player.body.maxVelocity.x = maxPlayerSpeed;

        emitter.pause();
        emitter.killAll();
      }
      function shellHit(player, shell) {
        var threshold = shell.x + shell.width / 2,
          playerX = player.x + player.width / 2;

        if (shell.body.touching.up) {
          if (playerX < threshold) shell.body.velocity.x = shellSpeed;
          else shell.body.velocity.x = -shellSpeed;
        }

        if (shell.body.touching.left) {
          shell.body.velocity.x = shellSpeed;
        }

        if (shell.body.touching.right) {
          shell.body.velocity.x = -shellSpeed;
        }

        player.body.velocity.y = -200;
      }
      function shellHitBaddie(shell, baddie) {
        if (!baddie.hit) {
          baddie.disableBody(false, false);

          var tween = this.tweens.add({
            targets: baddie,
            alpha: 0.3,
            scaleX: 1.5,
            scaleY: 1.5,
            ease: "Linear",
            duration: 200,
            onComplete: function () {
              destroyGameObject(baddie);
            },
          });

          shell.disableBody(false, false);

          var tween2 = this.tweens.add({
            targets: shell,
            alpha: 0.3,
            scaleX: 2,
            scaleY: 2,
            y: "-=100",
            rotation: -360,
            ease: "Linear",
            duration: 200,
            onComplete: function () {
              destroyGameObject(shell);
            },
          });
        }
      }

      function checkLadderTop(player, ladder) {
        if (
          Math.floor(player.y + player.height / 2) <=
          Math.ceil(ladder.y - ladder.height / 2)
        ) {
          if (cursors.down.isDown || Math.floor(prevPos) < Math.floor(yPos))
            return false;
          else return true;
        } else {
          return false;
        }
      }
      function isOnLadder() {
        onLadder = true;
        player.body.setAllowGravity(false);
      }

      function hitBaddie(player, baddie) {
        if (baddie.body.touching.up && !baddie.hit && !player.isChangingSize) {
          baddie.disableBody(false, false);
          player.setVelocityY(jumpVelocity);

          var tween = this.tweens.add({
            targets: baddie,
            alpha: 0.3,
            scaleX: 1.5,
            scaleY: 1.5,
            ease: "Linear",
            duration: 200,
            onComplete: function () {
              destroyGameObject(baddie);
            },
          });
        } else {
          playerHit.call(this);
        }
      }
      function playerHit() {
        if (player.isBig) {
          player.body.velocity.x = 0;
          player.body.velocity.y = -220;
          player.isChangingSize = true;

          var tween = this.tweens.add({
            targets: player,
            scaleX: 0.8,
            scaleY: 0.8,
            alpha: 0.3,
            yoyo: 2,
            repeat: 2,
            ease: "Linear",
            duration: 100,
            onComplete: function () {
              shrinkHero();
            },
          });
        } else {
          if (!player.invulnerable && !player.invincible) {
            if (player.invincible) {
              baddie.disableBody(false, false);
              var tween = this.tweens.add({
                targets: baddie,
                alpha: 0.3,
                y: "-=150",
                scaleX: 2.5,
                scaleY: 2.5,
                angle: 180,
                ease: "Linear",
                duration: 200,
                onComplete: function () {
                  destroyGameObject(baddie);
                },
              });
            } else {
              player.invulnerable = true;

              var currentHeartCount = player.hearts,
                currentHeart = hearts[currentHeartCount - 1],
                currentHeartOutline = heartOutlines[currentHeartCount - 1];

              var heartFade = this.tweens.add({
                targets: currentHeart,
                alpha: 0,
                scaleX: 0,
                scaleY: 0,
                ease: "Linear",
                duration: 200,
              });

              var heartsTimeline = this.tweens.createTimeline();

              heartsTimeline.add({
                targets: currentHeartOutline,
                scaleX: 0.5,
                scaleY: 0.5,
                ease: "Power1",
                duration: 200,
              });

              heartsTimeline.add({
                targets: currentHeartOutline,
                scaleX: 1,
                scaleY: 1,
                ease: "Power1",
                duration: 200,
              });

              heartsTimeline.play();

              player.hearts -= 1;

              if (player.hearts <= 0) {
                player.disableBody(false, false);

                var tween = this.tweens.add({
                  targets: player,
                  alpha: 0.3,
                  scaleX: 1.1,
                  scaleY: 1.1,
                  angle: 90,
                  x: player.x - 20,
                  y: player.y - 20,
                  ease: "Linear",
                  duration: 200,
                  onComplete: function () {
                    restartGame(this);
                  },
                  onCompleteScope: this,
                });
              } else {
                player.body.velocity.x = 0;
                player.body.velocity.y = -220;

                var tween = this.tweens.add({
                  targets: player,
                  alpha: 0.3,
                  ease: "Linear",
                  duration: 200,
                  onCompleteScope: this,
                });

                var timer = this.time.delayedCall(
                  vulnerableTime,
                  playerVulnerable,
                  [this]
                );
              }
            }
          }
        }
      }
      function destroyShell() {
        shell.disableBody(false, false);
        var destroyShell = this.tweens.add({
          targets: shell,
          alpha: 0.3,
          scaleX: 2,
          scaleY: 2,
          y: "-=100",
          rotation: -360,
          ease: "Linear",
          duration: 200,
          onComplete: function () {
            destroyGameObject(shell);
          },
        });
      }
      function playerVulnerable(game) {
        var death = game.tweens.add({
          targets: player,
          alpha: 1,
          ease: "Linear",
          duration: 200,
          onComplete: function () {
            player.invulnerable = false;
          },
          onCompleteScope: this,
        });
      }
      function restartGame(game) {
        game.scene.restart();
      }
      function buildTouchSlider(game) {
        sliderBar = game.add.sprite(0, 0, "touch-slider");
        sliderKnob = game.add.sprite(0, 0, "touch-knob");

        touchSlider = game.add.container(100, 450);
        touchSlider.add(sliderBar);
        touchSlider.add(sliderKnob);
        touchSlider.alpha = 0;
        touchSlider.setScrollFactor(0);
      }

      function moveLeft(acceleration) {
        var standing = player.body.blocked.down || player.body.touching.down;

        if (standing) {
          player.setAccelerationX(-acceleration);
        } else {
          player.setAccelerationX(-acceleration / 3);
        }
      }

      function moveRight(acceleration) {
        var standing = player.body.blocked.down || player.body.touching.down;

        if (standing) {
          player.setAccelerationX(acceleration);
        } else {
          player.setAccelerationX(acceleration / 3);
        }
      }
      function switchDirection(baddie) {
        baddie.body.velocity.x *= -1;

        baddie.previousX = baddie.x;
      }

      function update() {
        var standing = player.body.blocked.down || player.body.touching.down;
        if (player.isBig) jumpVelocity = jumpVelocityBig;
        else jumpVelocity = jumpVelocitySmall;
        for (var i = 0; i < coinTweens.length; i++) {
          var tween = coinTweens[i];
          if (tween) tween.updateTo("x", camera.scrollX + scoreCoin.x);
        }
        baddies.getChildren().forEach(function (theBaddie) {
          if (
            Math.abs(theBaddie.x - theBaddie.previousX) >= theBaddie.maxDistance
          ) {
            switchDirection(theBaddie);
          }
        }, this);
        if (cursors.left.isDown) {
          moveLeft(acceleration);
        } else if (cursors.right.isDown) {
          moveRight(acceleration);
        }

        if (this.input.pointer1.isDown || this.input.pointer2.isDown) {
          var leftHalf = config.width / 2;
          if (
            this.input.pointer1.x < leftHalf ||
            this.input.pointer2.x < leftHalf
          ) {
            var myMovePointer = null;

            if (
              this.input.pointer1.x < leftHalf &&
              this.input.pointer1.isDown
            ) {
              myMovePointer = this.input.pointer1;
            }
            if (
              this.input.pointer2.x < leftHalf &&
              this.input.pointer2.isDown
            ) {
              myMovePointer = this.input.pointer2;
            }

            if (myMovePointer) {
              if (!touchSlider.alpha) {
                touchSlider.alpha = 1;

                touchSlider.x = myMovePointer.x;

                touchSlider.y = myMovePointer.y - thumbSizeOffset;

                startX = myMovePointer.x;
                sliderKnob.x = 0;
              }

              if (myMovePointer.x < startX || myMovePointer.x > startX) {
                var movement = 0;
                if (myMovePointer.x < startX)
                  movement = startX - myMovePointer.x;
                if (myMovePointer.x > startX)
                  movement = myMovePointer.x - startX;

                if (movement > touchMoveThreshold) {
                  touchMoving = true;
                  var isTouch = true;
                  var sliderPos = 0;

                  if (myMovePointer.x < startX)
                    sliderPos = -(sliderBar.width / 4);

                  if (myMovePointer.x > startX) sliderPos = sliderBar.width / 4;

                  var tmpAcceleration = acceleration / 8;

                  if (movement > largeThumbMoveAcross) {
                    if (myMovePointer.x < startX)
                      sliderPos = -(sliderBar.width / 2);
                    if (myMovePointer.x > startX)
                      sliderPos = sliderBar.width / 2;

                    tmpAcceleration = acceleration;
                  }

                  var tween = this.tweens.add({
                    targets: sliderKnob,
                    x: sliderPos,
                    ease: "Power1",
                    duration: 300,
                  });
                  if (myMovePointer.x < startX) moveLeft(tmpAcceleration);
                  if (myMovePointer.x > startX) moveRight(tmpAcceleration);
                } else {
                  touchMoving = false;

                  var tween = this.tweens.add({
                    targets: sliderKnob,
                    x: 0,
                    ease: "Power1",
                    duration: 300,
                  });
                }
              }
            }
          }

          if (
            this.input.pointer1.x > leftHalf ||
            this.input.pointer2.x > leftHalf
          ) {
            var myJumpPointer = null;

            if (
              this.input.pointer1.x > leftHalf &&
              this.input.pointer1.isDown
            ) {
              myJumpPointer = this.input.pointer1;
            }
            if (
              this.input.pointer2.x > leftHalf &&
              this.input.pointer2.isDown
            ) {
              myJumpPointer = this.input.pointer2;
            }

            if (myJumpPointer) {
              prevPos = yPos;

              yPos = myJumpPointer.y;
              if (onLadder) {
                if (
                  Math.floor(player.y + player.height / 2) <=
                  Math.ceil(ladder.y - ladder.height / 2)
                ) {
                  player.setVelocityY(0);
                }
                if (Math.floor(prevPos) > Math.floor(yPos)) {
                  if (!myMovePointer) {
                    player.x = ladder.x;
                    player.setVelocityX(0);
                    player.setVelocityY(-100);
                  }
                }
                if (Math.floor(prevPos) < Math.floor(yPos)) {
                  if (!myMovePointer) {
                    player.x = ladder.x;
                    player.setVelocityX(0);
                    player.setVelocityY(100);
                  }
                }
              } else {
                if (prevPos - yPos > touchJumpThreshold) {
                  touchJump = true;
                }
              }
            }
          }
        } else {
          touchSlider.alpha = 0;
          startX = 0;
          touchMoving = false;
          if (onLadder) {
            player.setVelocityY(0);
          }
        }

        if (!cursors.right.isDown && !cursors.left.isDown && !touchMoving) {
          if (
            Math.abs(player.body.velocity.x) < 10 &&
            Math.abs(player.body.velocity.x) > -10
          ) {
            player.setVelocityX(0);
            player.setAccelerationX(0);
          } else {
            player.setAccelerationX(
              ((player.body.velocity.x > 0 ? -1 : 1) * acceleration) / 3
            );
          }
        }

        var d = new Date();
        var time = d.getTime();
        if (onLadder && !isTouch) {
          player.setVelocityY(0);

          if (cursors.up.isDown) {
            if (!cursors.left.isDown && !cursors.right.isDown) {
              player.x = ladder.x;

              player.setVelocityX(0);
              player.setVelocityY(-100);
            }
          }

          if (
            cursors.down.isDown &&
            !cursors.left.isDown &&
            !cursors.right.isDown
          ) {
            player.x = ladder.x;

            player.setVelocityX(0);
            player.setVelocityY(100);
          }
        }
        if (!standing && wasStanding) {
          edgeTimer = time + 100;
        }

        if (
          (standing || time <= edgeTimer) &&
          (cursors.up.isDown || touchJump) &&
          !jumping
        ) {
          player.setVelocityY(jumpVelocity);
          jumping = true;
        }

        if (!cursors.up.isDown) {
          if (player.body.touching.down) {
            jumping = false;
            touchJump = false;
            prevPos = 0;
          }
        }
        wasStanding = standing;
        if (!onLadder) player.body.setAllowGravity(true);
        onLadder = false;
      }

      function collectCoin(player, coin) {
        coin.disableBody(true, true);

        score += 10;
        scoreText.setText(score);
        var collectCoinTween = this.tweens.add({
          targets: coin,
          alpha: 0.3,
          angle: 720,
          x: scoreCoin.x,
          y: scoreCoin.y,
          scaleX: 0.5,
          scaleY: 0.5,
          ease: "Linear",
          duration: 500,
          onComplete: function () {
            destroyGameObject(coin);
          },
        });
        coinTweens.push(collectCoinTween);

        var scoreCoinTimeline = this.tweens.timeline({
          targets: scoreCoin,
          duration: 100,
          tweens: [
            {
              scaleX: 0.8,
              scaleY: 0.8,
              angle: "+=45",
            },
            {
              scaleX: 0.5,
              scaleY: 0.5,
              angle: "+=45",
            },
          ],
        });
      }
      function destroyGameObject(gameObject) {
        gameObject.destroy();
      }
    </script>
  </body>
</html>
